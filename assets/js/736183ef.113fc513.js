"use strict";(self.webpackChunktalawa_docs=self.webpackChunktalawa_docs||[]).push([[487399],{954539:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>t,default:()=>c,frontMatter:()=>o,metadata:()=>a,toc:()=>d});var i=r(785893),s=r(511151);const o={id:"api-error-handling-guide",title:"API Error Handling Guide"},t=void 0,a={id:"developers/talawa-api/api-error-handling-guide",title:"API Error Handling Guide",description:"This page outlines the core design principles for handling errors within the GraphQl Layer in Talawa-API code base and relaying said errors back to the client apps.",source:"@site/docs/developers/talawa-api/error-handling.md",sourceDirName:"developers/talawa-api",slug:"/developers/talawa-api/api-error-handling-guide",permalink:"/docs/developers/talawa-api/api-error-handling-guide",draft:!1,unlisted:!1,editUrl:"https://github.com/PalisadoesFoundation/talawa-docs/edit/develop/docs/developers/talawa-api/error-handling.md",tags:[],version:"current",frontMatter:{id:"api-error-handling-guide",title:"API Error Handling Guide"}},l={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Problems with Default GraphQL Errors",id:"problems-with-default-graphql-errors",level:2},{value:"Problems with This Approach",id:"problems-with-this-approach",level:4},{value:"User Errors vs Developer Errors",id:"user-errors-vs-developer-errors",level:2},{value:"The Solution",id:"the-solution",level:2},{value:"When To Model Errors In Schema And When Not To",id:"when-to-model-errors-in-schema-and-when-not-to",level:3},{value:"Cases Where Errors in Schema Is Recommended",id:"cases-where-errors-in-schema-is-recommended",level:2},{value:"The Approach in Practical Cases",id:"the-approach-in-practical-cases",level:4},{value:"Multiple Field Level Validation Errors -",id:"multiple-field-level-validation-errors--",level:3},{value:"API",id:"api",level:4},{value:"Client",id:"client",level:4},{value:"Atomic Errors -",id:"atomic-errors--",level:3},{value:"API",id:"api-1",level:4},{value:"Client",id:"client-1",level:4},{value:"Nested Resolver Errors. (Complex Objects)",id:"nested-resolver-errors-complex-objects",level:3},{value:"Nested Resolvers Errors (Scalar Fields)",id:"nested-resolvers-errors-scalar-fields",level:3},{value:"API",id:"api-2",level:4},{value:"Client",id:"client-2",level:4},{value:"Errors Defined in Schema Approach vs Default GraphQL Errors",id:"errors-defined-in-schema-approach-vs-default-graphql-errors",level:2}];function h(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"This page outlines the core design principles for handling errors within the GraphQl Layer in Talawa-API code base and relaying said errors back to the client apps."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#Introduction",children:"Introduction"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#Problem-with-default-Graphql-Errors",children:"Problem with default Graphql Errors"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#User-Errors-vs-Developer-Errors",children:"User Errors vs Developer Errors"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#When-To-Model-Errors-In-Schema-And-When-Not-To",children:"When To Model Errors In Schema And When Not To"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#Cases-Where-Errors-in-Schema-Is-Recommended",children:"Cases Where Errors in Schema Is Recommended"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#Multiple-Field-Level-Validation-Errors",children:"Multiple Field Level Validation Errors"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#Atomic-Errors",children:"Atomic Errors"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#Nested-Resolver-Errors-(Complex-Objects)",children:"Nested Resolver Errors. (Complex Objects)"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#Nested-Resolvers-Errors-(Scalar-Fields)",children:"Nested Resolvers Errors (Scalar Fields)"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#Errors-Defined-in-Schema-Approach-vs-Default-GraphQL-Errors",children:"Errors Defined in Schema Approach vs Default GraphQL Errors"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsxs)(n.p,{children:["GraphQL is an excellent tool for building APIs, especially when there is a need to provide clients with more control over the data they receive from the server. With GraphQL, clients can fetch only the specific data they require in the payload returned by the server, resulting in a more efficient data exchange. The data is presented in a form that closely resembles a graph, which means that all data exchanged between the client and API should be thought of in terms of graphs (learn more at ",(0,i.jsx)(n.a,{href:"https://graphql.org/learn/thinking-in-graphs/",children:"this link"}),")."]}),"\n",(0,i.jsx)(n.p,{children:"GraphQL effectively resolves relations that exist in the business logic of the application using field resolvers, but only if the client explicitly requests those relations to be resolved. This approach reduces unnecessary computations for data that the clients don't specifically need. A resolver is essentially a function with the same name as the field or relation it resolves and returns."}),"\n",(0,i.jsx)(n.p,{children:"The returned data is structured as a graph, where each node represents a meaningful object in the context of the logic, and the edges represent the relations between them."}),"\n",(0,i.jsx)(n.p,{children:"In summary, GraphQL allows clients to achieve the following (these points will be important later on):"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Query for a specific resolver that returns a relevant object (node) aligned with the API's logic."}),"\n",(0,i.jsx)(n.li,{children:"Fetch certain fields within the requested object (node) to optimize the request/response payload."}),"\n",(0,i.jsx)(n.li,{children:"When resolving relations (edges), make a nested query for interrelated objects (nodes)."}),"\n",(0,i.jsx)(n.li,{children:"Treat each node within the nested query as an individual entity in the graph; errors in one node should not affect other nodes in the graph."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This approach works perfectly when everything runs as expected. However, what happens if errors occur? How does GraphQL, by default, handle these four points that revolve around thinking in terms of graphs when mistakes are made?"}),"\n",(0,i.jsx)(n.h2,{id:"problems-with-default-graphql-errors",children:"Problems with Default GraphQL Errors"}),"\n",(0,i.jsx)(n.p,{children:"Let's delve into the issues related to default GraphQL errors through an example."}),"\n",(0,i.jsxs)(n.p,{children:["Suppose I am making a query on the ",(0,i.jsx)(n.code,{children:"signUp"})," mutation, which requires the parameters ",(0,i.jsx)(n.code,{children:"email"}),", ",(0,i.jsx)(n.code,{children:"name"}),", and ",(0,i.jsx)(n.code,{children:"password"}),". Now, let's consider a scenario where there is no user with the given email. In such a case, the default response is as follows:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'\\{\n  "data": \\{\n    "signUp": null\n  },\n  "errors": [\n    \\{\n      "path": [\n        "login"\n      ],\n      "locations": [\n        \\{\n          "line": 2,\n          "column": 3\n        }\n      ],\n      "message": "User not found"\n    }\n  ]\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"problems-with-this-approach",children:"Problems with This Approach"}),"\n",(0,i.jsx)(n.p,{children:"The current approach has several issues that can pose challenges for developers:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Lack of Type Safety in ",(0,i.jsx)(n.code,{children:"errors"})," Key:\nThe ",(0,i.jsx)(n.code,{children:"errors"})," key in a GraphQL response lacks type safety. GraphQL is appreciated for its consistency and type safety, which unfortunately isn't fully carried over to the ",(0,i.jsx)(n.code,{children:"errors"})," array. While the errors are specified, introspection does not provide the client with detailed information about what to expect in those errors. This lack of clarity makes the ",(0,i.jsx)(n.code,{children:"errors"})," array harder to evolve and extend."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Null Values in Nested Resolvers:\nWhen the ",(0,i.jsx)(n.code,{children:"errors"})," array is present in the response, the resulting query will return ",(0,i.jsx)(n.code,{children:"null"})," in the ",(0,i.jsx)(n.code,{children:"data"})," field. However, if a non-nullable field returns ",(0,i.jsx)(n.code,{children:"null"}),", GraphQL will raise an error. Consequently, if a nested resolver returns a null value, the entire data object is returned as null, and the error message won't provide additional information about why the field returned null unless explicitly handled in the resolver. Handling nullable nested resolvers introduces complexities for client applications, as they need to make extra efforts to extract and customize errors."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Complexity of GraphQL Errors vs. API Domain Errors:\nGraphQL errors are designed to encode exceptional scenarios, such as when a service is down or an internal failure occurs. However, errors that are part of the API domain should ideally be captured within that domain and relayed to the client as informational messages, not GraphQL errors. Distinguishing between GraphQL errors and domain-specific errors is crucial for a more effective error-handling strategy."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"By addressing these problems, developers can enhance the reliability and maintainability of GraphQL-based APIs, providing a more robust and user-friendly experience for clients."}),"\n",(0,i.jsx)(n.h2,{id:"user-errors-vs-developer-errors",children:"User Errors vs Developer Errors"}),"\n",(0,i.jsx)(n.p,{children:"In GraphQL, user errors and developer errors represent different types of issues that can occur during the execution of a GraphQL operation."}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"User Errors:\nUser errors are typically related to invalid input or requests made by the client. These errors occur when the client provides data that doesn't meet the requirements or constraints defined by the GraphQL schema or business logic. For example, if a required field is not provided or an incorrect argument value is passed, a user error may occur. User errors are considered part of the expected flow of the application and are not exceptional or unexpected."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Treating user errors as a form of data instead of errors allows for a more flexible and structured way of handling them. Instead of returning a generic error message, GraphQL enables you to provide specific error information along with the response. This allows clients to understand and react to user errors in a meaningful way. By modeling user errors as part of the response, you can provide detailed instructions or suggestions on how to fix the issue, enhancing the overall user experience."}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsx)(n.li,{children:"Developer Errors:\nDeveloper errors, on the other hand, are exceptional or unexpected issues that occur due to mistakes or bugs in the server-side implementation of the GraphQL API. These errors are not caused by user input but rather by issues with the server, the execution environment, or the logic of the GraphQL server implementation itself. Developer errors could include things like database connection failures, internal server errors, or unhandled exceptions."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"When developer errors occur, it is crucial to handle them gracefully and provide appropriate error messages or feedback to the client. GraphQL provides a mechanism to represent these errors using the errors field in the response. By including detailed error information, such as error codes or error messages, developers can diagnose and fix the underlying issues efficiently."}),"\n",(0,i.jsx)(n.p,{children:"In summary, distinguishing between user errors and developer errors in GraphQL allows for a clear separation of concerns. Treating user errors as data instead of generic errors enables better communication between the server and the client, facilitating a more intuitive and user-friendly experience. Developer errors, on the other hand, should be handled and reported in a way that helps developers identify and address issues in the server-side implementation."}),"\n",(0,i.jsx)(n.h2,{id:"the-solution",children:"The Solution"}),"\n",(0,i.jsxs)(n.p,{children:["The guiding philosophy here is that Errors should be considered exceptional. User data should never be represented as an Error. If negative guidance needs to be provided for actions that users can perform, it should be represented in GraphQL as Data rather than as an Error. Errors should exclusively represent developer errors or exceptional circumstances, such as when the database is offline (as highlighted by ",(0,i.jsx)(n.a,{href:"https://github.com/graphql/graphql-spec/issues/391#issuecomment-385553207",children:"Lee Byron in comments on the GraphQL-Spec repository"}),")."]}),"\n",(0,i.jsxs)(n.p,{children:["The Error Handling approach chosen for the Talawa API codebase is based on ",(0,i.jsxs)(n.a,{href:"https://productionreadygraphql.com/2020-08-01-guide-to-graphql-errors",children:["Marc-Andre Giroux's ",(0,i.jsx)(n.code,{children:"6a"})]}),"."]}),"\n",(0,i.jsxs)(n.p,{children:['In GraphQL, the majority of "Errors" are actually client-side errors, not server-side errors. For instance, errors like ',(0,i.jsx)(n.code,{children:"User Not Found"})," or ",(0,i.jsx)(n.code,{children:"Invalid Login Credentials"})," are not server errors; they are the result of the operation requested by the client. On the other hand, errors like ",(0,i.jsx)(n.code,{children:"Bad Gateway"})," or ",(0,i.jsx)(n.code,{children:"Internal Server Error"})," are indeed the server's fault."]}),"\n",(0,i.jsx)(n.p,{children:"Therefore, the Talawa API follows the 6a approach (Errors Union List + Interface Contract) to make it easier to send errors along with data, treating client-side errors as results, NOT errors."}),"\n",(0,i.jsx)(n.p,{children:"By adopting this approach, the Talawa API aims to provide a more refined and user-centric error handling mechanism, distinguishing between client-side and server-side errors while ensuring that user data is consistently represented as data rather than errors."}),"\n",(0,i.jsx)(n.h3,{id:"when-to-model-errors-in-schema-and-when-not-to",children:"When To Model Errors In Schema And When Not To"}),"\n",(0,i.jsx)(n.p,{children:"When deciding whether to model errors in the schema for fields in GraphQL, there are several factors to consider. The decision depends on the nature of the errors, the desired behavior of the API, and the needs of the client applications."}),"\n",(0,i.jsx)(n.p,{children:"Consider the types of errors that can occur for a particular field. If the errors are specific and can be categorized or have additional metadata associated with them, it might be beneficial to model them in the schema. For example, if a field can return validation errors, authorization errors, or specific business logic errors, modeling them in the schema can provide clients with detailed information about the error type."}),"\n",(0,i.jsx)(n.p,{children:"But for very basic field validation like checking for nullability for a field , type checking etc you can leave the default GraphQL server as is. There is no benefit for adding extra complexity for these cases."}),"\n",(0,i.jsx)(n.h2,{id:"cases-where-errors-in-schema-is-recommended",children:"Cases Where Errors in Schema Is Recommended"}),"\n",(0,i.jsx)(n.h4,{id:"the-approach-in-practical-cases",children:"The Approach in Practical Cases"}),"\n",(0,i.jsx)(n.p,{children:"Let's examine how this approach is applied in practical cases:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Multiple Field Level Validation Errors:"}),"\nThe approach allows sending all field errors at once, enabling clients to customize errors appropriately. For instance, consider a sign-up page where, in case of failed validation for each field, the app screen can display all errors simultaneously under the respective input boxes while also showing the success message for resolved data."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Atomic Errors:"}),"\nAtomicity in sending errors is achieved by ensuring that in some cases, either Error or Data is sent, not both. This helps maintain clarity and consistency in the response."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Nested Resolver Errors (Complex Objects):"}),"\nWhen dealing with relations in the graph sent by the server, each node should be treated individually for its errors. Errors in one node should not directly affect the attributes of other resolved related nodes. This allows for more precise error handling and prevents cascading errors that could impact the entire response."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Nested Resolver Errors (Scalar Fields):"}),"\nCustom scalar objects, such as Personally Identifiable Information (PII) fields like a user's ",(0,i.jsx)(n.code,{children:"email"}),", may require resolving with a custom resolver, and errors within these fields should not affect other scalar fields. This approach ensures that errors are localized and do not propagate to other parts of the response."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Now, let's explore each of these cases with example ",(0,i.jsx)(n.code,{children:"mutations/queries"})," within the ",(0,i.jsx)(n.code,{children:"talawa-api"}),". We will analyze both the API and client parts to gain a comprehensive understanding of how this approach is effectively implemented."]}),"\n",(0,i.jsx)(n.h3,{id:"multiple-field-level-validation-errors--",children:"Multiple Field Level Validation Errors -"}),"\n",(0,i.jsx)(n.h4,{id:"api",children:"API"}),"\n",(0,i.jsx)(n.p,{children:"Field Level Errors describe any errors assisciated with a specific field."}),"\n",(0,i.jsx)(n.p,{children:"In GraphQL, you can request specific fields from an API, and the API will respond with data for those fields. Field errors can occur when there's a problem with one of the fields you've requested."}),"\n",(0,i.jsxs)(n.p,{children:["For example Let us look at the ",(0,i.jsx)(n.code,{children:"signUp"})," Mutation."]}),"\n",(0,i.jsxs)(n.p,{children:["The type definitions relevant for ",(0,i.jsx)(n.code,{children:"signUp"})," Mutation->"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-gql",children:"  input SignUpInput \\{\n    firstName: String!\n    lastName: String!\n    email: EmailAddress!\n    password: String!\n    appLanguageCode: String\n    organizationUserBelongsToId: ID\n  }\n\n  type AuthData \\{\n    user: User!\n    accessToken: String!\n    refreshToken: String!\n    androidFirebaseOptions: AndroidFirebaseOptions!\n    iosFirebaseOptions: IOSFirebaseOptions!\n  }\n\n  type User \\{\n    tokenVersion: Int!\n    _id: ID\n    firstName: String!\n    lastName: String!\n    email: EmailAddress\n  }\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Now, let us delve into the definition of the error union for the ",(0,i.jsx)(n.code,{children:"signUp"})," mutation."]}),"\n",(0,i.jsx)(n.p,{children:"GraphQL unions provide a mechanism to represent various types of objects in your schema that share common fields. By defining a union, we can compose multiple types, which proves particularly useful when an entity can have multiple types."}),"\n",(0,i.jsxs)(n.p,{children:["In this context, the interface ",(0,i.jsx)(n.code,{children:"UserError"})," serves as an ",(0,i.jsx)(n.code,{children:"interface contract"}),". The precise significance of this interface will become evident as we progress to the client-side explanation section."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-gql",children:"// now begins the Error unions types, we can consume many error types in this\nunion SignUpError = EmailTaken | PasswordTooShort | UserError\n\ntype EmailTaken implements UserError \\{\n  message: String!\n  path: String!\n  suggestion: String!\n}\n\ntype PasswordTooShort implements UserError \\{\n  message: String!\n  path: String!\n  minimumLength: Int!\n}\n\ninterface UserError \\{\n  message: String!\n  path: String!\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["As you can see the ",(0,i.jsx)(n.code,{children:"signUp"})," mutation has a return type of ",(0,i.jsx)(n.code,{children:"SignUpResult!"})," which in turn contains ",(0,i.jsx)(n.code,{children:"signUpData"})," with the return type ",(0,i.jsx)(n.code,{children:"AuthData"})," and ",(0,i.jsx)(n.code,{children:"signUpErrors"})," with return type of an array of the ",(0,i.jsx)(n.code,{children:"SignUpError"})," union. This way the ",(0,i.jsx)(n.code,{children:"signUp"})," mutation returns both the actual relevant data and the errors as result."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-gql",children:"// Here is the return type of signup mutation  notice how the signUpData is nullable here, well that is optional.\n\ntype SignUpResult \\{\n    signUpData : AuthData ,\n    signUpErrors : [SignUpError!]!\n}\n\ntype Mutation \\{\n   signUp(input: SignUpInput!): SignUpResult!\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Let us look at the pseudo code for the resolver now."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'const resolvers = \\{\n  Mutation: \\{\n    signUp: async (parent, args, context) => \\{\n          //the general approach of how this would work.\n           userObj = \\{} ,\n           signUpErrors = []\n           If(CHECK DUPLICATION OF EMAIL ) \\{\n                 KEEP THE EMAIL FIELD OF  USEROBJ TO BE RETURNED AS NULL ; \n                 signUpErrors.push(\\{\n                      __typename: "EmailTaken" ,\n                        message: "Email is already taken"\n                        path: "UserInput.email"\n                        suggestion: `Try to provide a unique mail or make sure you have not created an account \n                        already`\n                 })\n           }\n\n           If (CHECK args.PASSWORD LENGTH) \\{\n                   signUpErrors.push(\\{\n                      __typename: "PasswordTooShort" ,\n                        message: "Password length is too short"\n                        path: "UserInput.password"\n                        minimumLength: 8\n                   })\n           }\n           // Approach when we need to fall on a general error based on the interface contract `UserError`\n           If (CERTAIN CHECK WHERE WE WOULD NEED TO ADD THAT ERROR IN THE \n                  signUpErrors ARRAY) \\{\n                    signUpErrors.push(\\{\n                            __typename:"UserError" ,\n                            message: "message" , \n                            path: "path"\n                    })\n                  \n            }\n\n          // Here we will be returning multiple errors in the form on an array of signUpErrors\n          if (IF signUpErrors IS NOT EMPTY) \\{\n               return  \\{\n                   signUpData:null, \n                   signUpErrors\n\n               }\n          }\n          \n          EVERYTHING IS OKAY, CREATE THE USER IN DB,\n          \n          CreatedUserObj = DB.CREATE(USER);\n\n          return  \\{\n                   signUpData: \\{\n                         user : CreatedUserObj,\n                          .... other AuthData fields\n                   } , \n                   signUpErrors\n\n           }\n\n     }\n  }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"In this approach for resolving Field Errors, two significant features are highlighted:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Multiple Errors Handling:"}),"\nThe approach allows for sending multiple errors back to the client when necessary. This capability proves beneficial when client applications need to display those errors concurrently with relevant UI elements. By providing multiple errors, the client can obtain a comprehensive view of the issues encountered during the field resolution process."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"General Purpose Interface Contract - UserError:"}),"\nTo cater to scenarios where a general-purpose error needs to be sent back to the client, the approach employs a versatile interface contract called ",(0,i.jsx)(n.code,{children:"UserError"}),". This interface acts as a fallback mechanism, ensuring that clients receive informative error messages even in cases where specific error types are not applicable. It enhances error handling and communication between the server and client, offering a consistent and user-friendly experience."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"client",children:"Client"}),"\n",(0,i.jsx)(n.p,{children:"Let us take a look at how the clients would be making this query."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-gql",children:'mutation \\{\n  signUp(\n    input: \\{\n      firstName: "Harry"\n      lastName: "Potter"\n      email: "someDuplicateEmail"\n      password: "12345"\n    }\n    ) \\{\n    signUpData \\{ \n      user: \\{\n        _id,\n        firstName,\n        lastName,\n        email\n      } ,\n      accessToken,\n      refreshToken\n     }\n    signUpErrors \\{\n      # Specific cases\n      ... on EmailTaken \\{\n        __typename\n        message\n        path\n        suggestion\n      }\n\n      ... on PasswordTooShort \\{\n        __typename\n        message\n        path\n        minimumLength\n      }\n\n      # Interface contract to handle general purpose Error\n      ... on UserError \\{\n        message\n        path\n      }\n    }\n  }\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["As evident from this mutation input, the subsequent mutation should lead to the occurrence of the ",(0,i.jsx)(n.code,{children:"EmailTaken"})," and ",(0,i.jsx)(n.code,{children:"PasswordTooShort"})," Errors, as dictated by our resolver."]}),"\n",(0,i.jsxs)(n.p,{children:["The inclusion of the ",(0,i.jsx)(n.code,{children:"UserError"})," interface allows for the handling of any general-purpose error, granting us the advantage of an extensible interface coupled with the expressive nature of the union. This combination provides a flexible error-handling approach, enabling seamless communication between the server and client."]}),"\n",(0,i.jsx)(n.p,{children:"Consequently, the response resulting from this mutation will resemble the following structure:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'\\{\n  "data": \\{\n    "signUpData": null,\n    "signUpErrors": [\n      \\{\n        "__typename": "EmailTaken",\n        "message": "Email is already taken",\n        "path": "UserInput.email",\n        "suggestion": "Try to provide a unique mail or sure you have not created an account already"\n      },\n      \\{\n        "__typename": "PasswordTooShort",\n        "message": "Password length is too short",\n        "path": "UserInput.password",\n        "minimumLength": 8\n      }\n    ]\n  }\n}\n\n'})}),"\n",(0,i.jsx)(n.p,{children:"As observed,"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"signUpErrors"})," section comprises the anticipated errors, which are typesafe and accompanied by custom error messages. This robust error-handling approach ensures that clients receive meaningful and precise information about encountered issues."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"user"})," field is null in this instance because the operation encountered a failure, preventing the creation of a user object in the database. This outcome aligns with the expected behavior, and the response accurately reflects the result of the operation."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"atomic-errors--",children:"Atomic Errors -"}),"\n",(0,i.jsx)(n.h4,{id:"api-1",children:"API"}),"\n",(0,i.jsx)(n.p,{children:"Field Level Errors describe any errors assisciated with a specific field."}),"\n",(0,i.jsx)(n.p,{children:"In GraphQL, you can request specific fields from an API, and the API will respond with data for those fields. Field errors can occur when there's a problem with one of the fields you've requested."}),"\n",(0,i.jsxs)(n.p,{children:["For example Let us look at a hypothetical ",(0,i.jsx)(n.code,{children:"login"})," Mutation."]}),"\n",(0,i.jsxs)(n.p,{children:["The type definitions relevant for ",(0,i.jsx)(n.code,{children:"login"})," Mutation->"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-gql",children:"\n  type User \\{\n    _id: ID!\n    name: String!\n    email: String!\n    joinedOrganization: Organization\n    image: Image!\n  }\n  \n  type Organization \\{\n    name: String!,\n    description: String!\n  }\n\n  type Image \\{\n    filepath: String!\n    size: Int!\n  }\n\n  type LoginPayload \\{\n    authtoken: String!\n    user: User!\n  }\n\n  input LoginInput \\{\n    email: EmailAddress!,\n    password: String!\n  }\n\n  type Mutation \\{\n    login(input: LoginInput!): LoginPayload!\n  }\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Now, let us take a look at the definition of error union for the ",(0,i.jsx)(n.code,{children:"login"})," mutation."]}),"\n",(0,i.jsx)(n.p,{children:"GraphQL unions are a way to represent different types of objects in your schema that share some common fields. A union is a composition of multiple types and is useful when we require type definition for an entity that could have multiple types"}),"\n",(0,i.jsxs)(n.p,{children:["The interface ",(0,i.jsx)(n.code,{children:"UserError"})," will act as an ",(0,i.jsx)(n.code,{children:"interface contract"}),". The exact purpose for it will be cleared when we reach the  client side explaination part."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-gql",children:"\n# the Error unions types, we can consume many error types in this\n  \n  \n  union LoginError = EmailNotFound | PasswordInvalid | UserError\n\n  interface UserError \\{\n    message: String!\n    path: String!\n  }\n\n  type EmailNotFound implements UserError \\{\n    message: String!\n    path: String!\n  }\n\n  type PasswordInvalid implements UserError \\{\n    message: String!\n    path: String!\n  }\n\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"login"})," mutation has a return type of ",(0,i.jsx)(n.code,{children:"LoginResult!"})," which in turn contains ",(0,i.jsx)(n.code,{children:"loginPayload"})," and ",(0,i.jsx)(n.code,{children:"loginErrors"})," with return type of an array of the ",(0,i.jsx)(n.code,{children:"LoginError"})," union. This way the ",(0,i.jsx)(n.code,{children:"login"})," mutation returns both the actual relevant data and the errors as result."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-gql",children:"# Here is the return type of login mutation.\n\n  type LoginResult \\{\n    loginPayload: LoginPayload\n    loginError: [LoginError!]!\n  }\n\n  type Mutation \\{\n    login(input: LoginInput!): LoginResult!\n  }\n\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Let us look at the pseudo code for the resolvers now. Right now let us just focus on the login resolver. In both cases of Atomic Errors that is ",(0,i.jsx)(n.code,{children:"UserNotFound"})," and ",(0,i.jsx)(n.code,{children:"InvalidPassword"})," the ",(0,i.jsx)(n.code,{children:"loginPayload"})," field returns null whereas the ",(0,i.jsx)(n.code,{children:"loginErrors"}),' field returns said errors. For other non-atomic errors which are not "failing errors", can be sent as an array directly along with the User in the db and accesstoken.']}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'const resolvers = \\{\n  \n  Mutation: \\{\n    login: (parent: any, args: \\{ input: LoginInput }) => \\{\n      \n      const \\{ email, password } = args.input;\n\n      userObj = \\{};\n      loginErrors = [];\n\n      if(IF USER WITH EMAIL DOES NOT EXIST) \\{\n        loginErrors.push(\\{\n          __typename: "EmailNotFound" ,\n          message: "User with Email does not exist"\n          path: "LoginInput.email"\n        })\n\n        return \\{\n          loginPayload:null,\n          loginErrors,\n        }\n      }\n\n      if(IF PASSWORDS DOES NOT MATCH) \\{\n        loginErrors.push(\\{\n          __typename: "PasswordInvalid" ,\n          message: "Passwords do not match"\n          path: "LoginInput.password"\n        })\n\n        return \\{\n          loginPayload:null,\n          loginErrors\n        }\n      }\n      \n      userObj = DB.FIND(USER WITH EMAIL AND PASSWORD);\n\n      accessToken = GENERATE AND SAVE ACCESS TOKEN.\n\n\n      if(IF ANY OTHER ERRORS )\\{\n        FOR EACH ERROR->\n        loginErrors.push(\\{\n          __typename: "UserError" ,\n          message: "message"\n          path: "PATH"\n        })\n      }\n      \n      return \\{\n        loginPayload:\\{\n          userObj,\n          accessToken\n        },\n        loginErrors,\n      }\n    },\n  },\n\n  // We will expand more into this later in the documentation.\n  User: \\{\n    email: (parent: \\{ email: string }) => \\{\n      // Logic to restrict PII access to email field\n      if (IF REQUESTING USER IS NOT AUTHORISED TO VIEW THE EMAIL OF SAID USER) \\{\n        return \'********\'; // return ENCRYPTED email value  \n      }\n      return email;\n    },\n    joinedOrganization: (parent: \\{ joinedOrganization: Organization } , args , context) => \\{\n      // Logic to retrieve joined organization data\n      // You can fetch organization data from a database or another source\n      \n      if(IF context.userID IS NOT AUTHORISED TO VIEW THE JOINED ORGANIZATION OF THE REQUESTED USER)\\{\n        return null;\n      }\n\n      return organization;\n    },\n  },\n};\n\n'})}),"\n",(0,i.jsx)(n.p,{children:"In this approach for resolving Field Errors ->"}),"\n",(0,i.jsx)(n.h4,{id:"client-1",children:"Client"}),"\n",(0,i.jsx)(n.p,{children:"Let us take a look at how the clients would be making this query."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-gql",children:'mutation \\{\n  login(\n    input: \\{\n      email: ""\n      password: "12345"\n    }\n  ) ... on LoginPayload \\{\n      authtoken\n      # Right now let\'s just focus on the the fields which will not require a custom scalar unlike `email` or `joinedOrganization`\n      user \\{\n        _id\n        image \\{\n          filepath\n          size\n        }\n      }\n    }\n    ... on LoginError \\{\n      __typename\n      ... on EmailNotFound \\{\n        message\n      }\n      ... on InvalidPassword \\{\n        message\n      }\n      ... on IsPasswordValid \\{\n        message\n      }\n    }\n  \n}\n\n'})}),"\n",(0,i.jsx)(n.p,{children:"In this client-side query, we use the ... operator to fragment the result based on the type name in the LoginResult union. This allows us to specify the fields to be selected for each possible type within the union."}),"\n",(0,i.jsx)(n.p,{children:"For the LoginPayload type, we select the authtoken field and the fields for the User type, including _id and image."}),"\n",(0,i.jsx)(n.p,{children:"For the LoginError type, we select the __typename field to identify the specific error type within the union. We then use the ... on syntax to specify the fields for each error type (EmailNotFound, InvalidPassword, IsPasswordValid) implementing the UserError interface. In this example, we only select the message field for each error type."}),"\n",(0,i.jsx)(n.p,{children:"By using fragment spreading, we can handle different types within the LoginResult union and select the appropriate fields accordingly."}),"\n",(0,i.jsx)(n.p,{children:"Here's how the response would look like for different error scenarios:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"If a user with the provided email does not exist:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'\\{\n  "data": \\{\n    "login": \\{\n      "loginPayload": null,\n      "loginErrors": [\n        \\{\n          "__typename": "EmailNotFound",\n          "message": "User with Email does not exist",\n          "path": "LoginInput.email"\n        }\n      ]\n    }\n  }\n}\n\n'})}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsx)(n.li,{children:"If the provided password is invalid:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'\\{\n  "data": \\{\n    "login": \\{\n      "loginPayload": null,\n      "loginErrors": [\n        \\{\n          "__typename": "PasswordInvalid",\n          "message": "Passwords do not match",\n          "path": "LoginInput.password"\n        }\n      ]\n    }\n  }\n}\n\n'})}),"\n",(0,i.jsxs)(n.ol,{start:"3",children:["\n",(0,i.jsx)(n.li,{children:"If there are other unspecified errors in the loginErrors array:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'\\{\n  "data": \\{\n    "login": \\{\n      "loginPayload": null,\n      "loginErrors": [\n        \\{\n          "__typename": "UserError",\n          "message": "Some error message",\n          "path": "Some path"\n        },\n        \\{\n          "__typename": "UserError",\n          "message": "Another error message",\n          "path": "Another path"\n        }\n      ]\n    }\n  }\n}\n\n'})}),"\n",(0,i.jsx)(n.p,{children:"In each case, the loginPayload field is set to null since the login was unsuccessful. The loginErrors field contains an array of error objects, where each object includes the __typename to identify the specific error type, the error message, and the path where the error occurred."}),"\n",(0,i.jsx)(n.p,{children:"Please note that the actual error handling and response structure may vary depending on your implementation and the GraphQL client library or framework you are using. The provided examples illustrate the general structure of the response for different error scenarios."}),"\n",(0,i.jsx)(n.h3,{id:"nested-resolver-errors-complex-objects",children:"Nested Resolver Errors. (Complex Objects)"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Make sure you are completely thorough with the above two sections before proceeding further."})}),"\n",(0,i.jsx)(n.p,{children:"To understand nested resolvers in terms of graph nomenclature, it's helpful to think of GraphQL schemas as directed graphs, where the types are nodes and the fields are edges. Each field in the schema has a resolver associated with it, which determines how the data for that field should be retrieved."}),"\n",(0,i.jsx)(n.p,{children:"When a GraphQL query is executed, the resolver for the root field is called first, and then the resolvers for any nested fields are called recursively. This process continues until all of the fields in the query have been resolved."}),"\n",(0,i.jsx)(n.p,{children:"Overall, nested resolvers are an important concept in GraphQL because they allow you to retrieve complex data structures in a flexible and efficient way, while keeping your schema simple and easy to understand."}),"\n",(0,i.jsx)(n.p,{children:"As such we will also need to make sure Errors in one node should not break the entire query."}),"\n",(0,i.jsx)(n.p,{children:"Let's First make a small adjustment to our Schema and Resolvers,"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-gql",children:"\n  type Organization \\{\n    name: String!\n    description: String!\n  }\n\n  interface OrganizationError \\{\n    message: String!\n    path: String!\n  }\n\n  type UnauthorizedError implements OrganizationError \\{\n    message: String!\n    path: String!\n  }\n\n  union OrganizationErrors = UnauthorizedError | OrganizationError\n\n  type OrganizationResult \\{\n    organizationPayload: Organization\n    organizationErrors: [OrganizationErrors!]!\n  }\n\n  type User \\{\n    _id: ID!\n    email: String!\n    joinedOrganization: OrganizationResult!\n    image: Image!\n  }\n\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"OrganizationErrors"}),": It represents the possible types of errors that can occur related to organizations.\nIt includes the ",(0,i.jsx)(n.code,{children:"UnauthorizedError"})," type, which represents an unauthorized error related to organizations.\nIt can also include other types that implement the ",(0,i.jsx)(n.code,{children:"OrganizationError"})," interface.\nThe ",(0,i.jsx)(n.code,{children:"OrganizationErrors"})," union allows for flexibility in handling different types of errors that can occur in operations related to organizations. It ensures that the result can contain the appropriate error type within the union."]}),"\n",(0,i.jsxs)(n.p,{children:["Certainly! Here's an explanation of the ",(0,i.jsx)(n.code,{children:"OrganizationResult"})," type:"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"OrganizationResult"})," type represents the result of an operation related to organizations. It consists of two fields: ",(0,i.jsx)(n.code,{children:"organizationPayload"})," and ",(0,i.jsx)(n.code,{children:"organizationErrors"}),".\nThe ",(0,i.jsx)(n.code,{children:"organizationPayload"})," field contains the payload for the operation, which includes the ",(0,i.jsx)(n.code,{children:"name"})," and ",(0,i.jsx)(n.code,{children:"description"})," of the organization. This field represents the successful result of the operation, providing the organization data.\nThe ",(0,i.jsx)(n.code,{children:"organizationErrors"})," field is a list of errors that occurred during the operation. It can include various types of errors, such as the ",(0,i.jsx)(n.code,{children:"UnauthorizedError"})," type or other types that implement the ",(0,i.jsx)(n.code,{children:"OrganizationError"})," interface.\nThis field allows for proper error handling and provides details about any issues encountered during the organization-related operation. The ",(0,i.jsx)(n.code,{children:"OrganizationResult"})," type ensures that both successful results and errors are properly represented and returned in a consistent manner."]}),"\n",(0,i.jsxs)(n.p,{children:["Let's Modify the nested resolver for ",(0,i.jsx)(n.code,{children:"joinedOrganization"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"const resolver  = \\{\n   Mutation: \\{\n    login: (parent: any, args: \\{ input: LoginInput }) => \\{\n    // Implementation of the login mutation resolver\n    },\n  },\n  User:\\{\n    email:(parent:User) =>\\{\n      // Implementation of the email resolver which will be explained later\n    },\n    joinedOrganization: (parent: User , args , context) => \\{\n      // Logic to retrieve joined organization data\n      \n      if (IF parent._id IS PRIVATE AND context.userID IS UNAUTHORISED TO ACCESS THE DATA OF THE REQUESTED USER) \\{\n\n        const unauthorizedError = \\{\n          __typename: 'UnauthorizedError',\n          message: 'Unauthorized',\n          path: 'User.joinedOrganization',\n        };\n\n        return \\{\n          organizationPayload: null,\n          organizationErrors: [unauthorizedError],\n        };\n      }\n\n      if (ANY OTHER ERROR) \\{\n        \n        const organizationError = \\{\n          __typename: 'OrganizationError',\n          message: 'Unauthorized',\n          path: 'User.joinedOrganization',\n        };\n\n        return \\{\n          organizationPayload: null,\n          organizationErrors: [organizationError],\n        };\n      }\n\n      return \\{\n        organizationPayload: organization,\n        organizationErrors: [],\n      };\n    },\n\n  }\n}\n\n"})}),"\n",(0,i.jsx)(n.p,{children:"In this updated resolver, the joinedOrganization field resolver for the User type includes the additional logic to check if the requesting user is authorized to access the data of the requested user. If the conditions are met, it returns the organization data within the organizationPayload field. If not authorized, it returns an UnauthorizedError within the organizationErrors field."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-gql",children:"mutation Login($input: LoginInput!) \\{\n  login(input: $input) \\{\n    loginPayload \\{\n      authtoken\n      user \\{\n        _id\n        email\n        joinedOrganization \\{\n         \n            organizationPayload \\{\n              ... on Organization \\{\n                name\n                description\n              }\n            }\n            organizationErrors \\{\n              __typename\n              ... on UnauthorizedError \\{\n                message\n                path\n              }\n              ... on OrganizationError \\{\n                message\n                path\n              }\n            }\n          \n        }\n      }\n    }\n    loginErrors \\{\n      __typename\n      ... on EmailNotFound \\{\n        message\n        path\n      }\n      ... on PasswordInvalid \\{\n        message\n        path\n      }\n      ... on IsPasswordValid \\{\n        message\n        path\n      }\n    }\n  }\n}\n\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"joinedOrganization"})," field is a nested field within the ",(0,i.jsx)(n.code,{children:"login"})," mutation. It represents the organization-related data for the logged-in user. It is accessed within the ",(0,i.jsx)(n.code,{children:"user"})," field, which is part of the ",(0,i.jsx)(n.code,{children:"loginPayload"})," field."]}),"\n",(0,i.jsxs)(n.p,{children:["Within the ",(0,i.jsx)(n.code,{children:"joinedOrganization"})," field, there are two possible selections: ",(0,i.jsx)(n.code,{children:"organizationPayload"})," and ",(0,i.jsx)(n.code,{children:"organizationErrors"}),". The ",(0,i.jsx)(n.code,{children:"organizationPayload"})," field represents the successful result of the joined organization data retrieval. It includes the ",(0,i.jsx)(n.code,{children:"name"})," and ",(0,i.jsx)(n.code,{children:"description"})," fields, which provide information about the joined organization."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"organizationErrors"})," field is a list of errors that can occur during the joined organization data retrieval. It includes the ",(0,i.jsx)(n.code,{children:"__typename"}),", ",(0,i.jsx)(n.code,{children:"message"}),", and ",(0,i.jsx)(n.code,{children:"path"})," fields. Specifically, it includes the ",(0,i.jsx)(n.code,{children:"UnauthorizedError"})," type, which represents an unauthorized error related to accessing the joined organization. Additionally, it includes any other types that implement the ",(0,i.jsx)(n.code,{children:"OrganizationError"})," interface, providing further details about potential errors."]}),"\n",(0,i.jsxs)(n.p,{children:["By including both the ",(0,i.jsx)(n.code,{children:"organizationPayload"})," and ",(0,i.jsx)(n.code,{children:"organizationErrors"})," fields within the ",(0,i.jsx)(n.code,{children:"joinedOrganization"})," field, this query allows for handling both successful results and any errors that may occur during the joined organization data retrieval."]}),"\n",(0,i.jsxs)(n.p,{children:["Here's an example of a response from Apollo Server for a query that represents a successful login but unauthorized access to the ",(0,i.jsx)(n.code,{children:"joinedOrganization"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'\\{\n  "data": \\{\n    "login": \\{\n      "loginPayload": \\{\n        "authtoken": "abc123",\n        "user": \\{\n          "_id": "123",\n          "email": "example@example.com",\n          "joinedOrganization": \\{\n            "organizationPayload": null,\n            "organizationErrors": [\n              \\{\n                "__typename": "UnauthorizedError",\n                "message": "Unauthorized access to joined organization",\n                "path": "User.joinedOrganization"\n              }\n            ]\n          }\n        }\n      },\n      "loginErrors": null\n    }\n  }\n}\n\n'})}),"\n",(0,i.jsxs)(n.p,{children:["In this response, the ",(0,i.jsx)(n.code,{children:"login"})," mutation was successful, resulting in a valid authentication token (",(0,i.jsx)(n.code,{children:"authtoken"}),"). The ",(0,i.jsx)(n.code,{children:"user"})," field represents the logged-in user, with an ",(0,i.jsx)(n.code,{children:"_id"})," and ",(0,i.jsx)(n.code,{children:"email"}),". However, when attempting to access the ",(0,i.jsx)(n.code,{children:"joinedOrganization"}),", the response indicates that it is unauthorized. The ",(0,i.jsx)(n.code,{children:"organizationPayload"})," is set to ",(0,i.jsx)(n.code,{children:"null"}),", indicating that no organization data was returned. Instead, the ",(0,i.jsx)(n.code,{children:"organizationErrors"})," field contains an error object with the ",(0,i.jsx)(n.code,{children:"__typename"})," of ",(0,i.jsx)(n.code,{children:"UnauthorizedError"}),", along with the ",(0,i.jsx)(n.code,{children:"message"})," and ",(0,i.jsx)(n.code,{children:"path"})," fields providing information about the unauthorized access to the joined organization."]}),"\n",(0,i.jsx)(n.p,{children:"This response structure allows the client to handle both successful results and potential errors, such as unauthorized access to certain resources, in a standardized manner."}),"\n",(0,i.jsx)(n.h3,{id:"nested-resolvers-errors-scalar-fields",children:"Nested Resolvers Errors (Scalar Fields)"}),"\n",(0,i.jsxs)(n.p,{children:["In GraphQL, a scalar field resolver is a resolver function that is responsible for resolving the value of a scalar field. A scalar field is a field that has a scalar type, such as a ",(0,i.jsx)(n.code,{children:"String"}),", ",(0,i.jsx)(n.code,{children:"Int"}),", or ",(0,i.jsx)(n.code,{children:"Boolean"})," or any other Custom Scalar type."]}),"\n",(0,i.jsx)(n.p,{children:"In Graphql Server, resolving fields is done using resolver functions. Resolver functions are responsible for fetching the data for a field, and they are defined in the resolver map, which maps the types and fields in the schema to their respective resolver functions."}),"\n",(0,i.jsx)(n.p,{children:"When a GraphQL query is received by the server, Graphql Server parses the query and traverses the schema to determine which resolver functions need to be called to resolve the requested fields. For each field in the query, Graphql Server calls the resolver function associated with that field to fetch the data."}),"\n",(0,i.jsx)(n.p,{children:"Resolver functions can be synchronous or asynchronous, and they can return the data for the field directly, or they can return a Promise that resolves to the data. If a resolver function returns a Promise, Graphql Server will wait for the Promise to resolve before continuing to resolve other fields."}),"\n",(0,i.jsxs)(n.p,{children:["Nested scalar field resolvers in GraphQL are resolver functions that are used to resolve the value of scalar fields that are nested within other fields. For example, consider a ",(0,i.jsx)(n.code,{children:"User"})," type. Here, the ",(0,i.jsx)(n.code,{children:"email"})," field is a PII (Personal Identifiable Information) field and would be encrypted at rest and in transit and thus need to be resolved with its own custom resolver."]}),"\n",(0,i.jsx)(n.p,{children:"We would need to resolve that field seperately when we are fetching a user and treat its errors like it is a nested resolver."}),"\n",(0,i.jsx)(n.h4,{id:"api-2",children:"API"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-gql",children:"\ntype EmailAdressResult \\{\n  emailData:EmailAddress,\n  emailErrors:[EmailErrors!].\n}\n\nunion EmailErrors = PIIError | AccessControlError\n\ntype PIIError implements AccessControlError \\{\n  message: String!,\n  authorisedRole: String!\n}\n\ninterface AccessControlError \\{\n  message: String!,\n  authorisedRole: String!\n}\n\ntype User \\{\n    _id: ID!\n    email: EmailAdressResult!\n    joinedOrganization: OrganizationResult!\n    image: Image!\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Now let's take a look at their ",(0,i.jsx)(n.code,{children:"user"})," query  resolver types ->"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-gql",children:"type UserResult \\{\n    userData: User ,\n    userErrors: [UserError!]\n}\n\n\n\ntype Query \\{\n   user(id: ID!): UserResult!\n}\n\n"})}),"\n",(0,i.jsx)(n.p,{children:"And now finally take a look at their resolvers ->"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'const resolver  = \\{\n   Mutation: \\{\n    login: (parent: any, args: \\{ input: LoginInput }) => \\{\n    // Implementation of the login mutation resolver\n    },\n  },\n  User:\\{\n    email:(parent:User) =>\\{\n\n      const email = parent.email;\n      let emailError= [];\n      if(NOT AUTHRORISED TO VIEW PII OF PARENT USER) \\{\n        emailErrors.push(\\{\n          __typename: "PIIError",\n          message: "Cannout access this info",\n          authorisedRole: "Authorised roles are : ..."\n        })\n      }\n\n      return \\{\n        emailData: !emailErrors ? email : encrypted(email),\n        emailErrors: emailErrors,\n      };\n\n    },\n    joinedOrganization: (parent: User , args , context) => \\{\n      // Implementation of the joinedOrganization resolver\n    },\n\n  }\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"email"})," resolver checks if the requesting user is authorized to access the email information of the parent user. If unauthorized, it adds a ",(0,i.jsx)(n.code,{children:"PIIError"})," object to the ",(0,i.jsx)(n.code,{children:"emailErrors"})," array. Otherwise, it returns the email information (",(0,i.jsx)(n.code,{children:"emailData"}),") and any errors (",(0,i.jsx)(n.code,{children:"emailErrors"}),") within an object. This resolver allows for controlled access to sensitive email information based on authorization rules, returning the data or appropriate errors accordingly."]}),"\n",(0,i.jsx)(n.h4,{id:"client-2",children:"Client"}),"\n",(0,i.jsx)(n.p,{children:"If the query is made to access an email of another user like this ->"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-gql",children:"#Here the requesting user i.e context.user has an id of 1 \nmutation Login($input: LoginInput!) \\{\n  login(input: $input) \\{\n    loginPayload \\{\n      authtoken\n      user \\{\n        _id\n        email \\{\n          emailData\n          emailErrors \\{\n            __typename\n            ... on PIIError \\{\n              message\n              authorisedRole\n            }\n          }\n        }\n        joinedOrganization \\{\n         \n            organizationPayload \\{\n              ... on Organization \\{\n                name\n                description\n              }\n            }\n            organizationErrors \\{\n              __typename\n              ... on UnauthorizedError \\{\n                message\n                path\n              }\n              ... on OrganizationError \\{\n                message\n                path\n              }\n            }\n          \n        }\n      }\n    }\n    loginErrors \\{\n      __typename\n      ... on EmailNotFound \\{\n        message\n        path\n      }\n      ... on PasswordInvalid \\{\n        message\n        path\n      }\n      ... on IsPasswordValid \\{\n        message\n        path\n      }\n    }\n  }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"Since here the context user is not allowed to access the email field the returned response is something like this ->"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'\\{\n  "data": \\{\n    "login": \\{\n      "loginPayload": \\{\n        "authtoken": "abc123",\n        "user": \\{\n          "_id": "123",\n          "email": \\{\n            "emailData": null,\n            "emailErrors": [\n              \\{\n                "__typename": "PIIError",\n                "message": "Unauthorized access to email",\n                "authorisedRole": "Admin"\n              }\n            ]\n          },\n          "joinedOrganization": \\{\n            "organizationPayload": \\{\n              "name": "Example Organization",\n              "description": "Organization description"\n            },\n            "organizationErrors": null\n          }\n        }\n      },\n      "loginErrors": null\n    }\n  }\n}\n\n\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Certainly! Here's a concise explanation of the response in case of a PII error in the ",(0,i.jsx)(n.code,{children:"email"})," field, along with all other queries running successfully:"]}),"\n",(0,i.jsxs)(n.p,{children:["The response includes a ",(0,i.jsx)(n.code,{children:"loginPayload"})," with an authentication token and a ",(0,i.jsx)(n.code,{children:"user"})," object containing various fields. The ",(0,i.jsx)(n.code,{children:"email"})," field within the ",(0,i.jsx)(n.code,{children:"user"})," object has an ",(0,i.jsx)(n.code,{children:"emailData"})," field set to ",(0,i.jsx)(n.code,{children:"null"})," due to unauthorized access. The ",(0,i.jsx)(n.code,{children:"emailErrors"})," field contains an array with a single ",(0,i.jsx)(n.code,{children:"PIIError"})," object, indicating the unauthorized access to the email. The ",(0,i.jsx)(n.code,{children:"PIIError"})," object provides the error ",(0,i.jsx)(n.code,{children:"message"})," and specifies the required ",(0,i.jsx)(n.code,{children:"authorisedRole"})," for access. The ",(0,i.jsx)(n.code,{children:"joinedOrganization"})," field returns the organization data within the ",(0,i.jsx)(n.code,{children:"organizationPayload"})," field, while the ",(0,i.jsx)(n.code,{children:"organizationErrors"})," field is set to ",(0,i.jsx)(n.code,{children:"null"}),", indicating no errors. Additionally, the ",(0,i.jsx)(n.code,{children:"loginErrors"})," field is ",(0,i.jsx)(n.code,{children:"null"}),", indicating no errors for other queries. This response structure enables handling both successful results and potential errors, ensuring appropriate communication of the PII error in the ",(0,i.jsx)(n.code,{children:"email"})," field."]}),"\n",(0,i.jsx)(n.p,{children:'Since some scalar fields are database intensive to compute within their own custom resolver and because there are not a lot of fields which can fall under "scalars which need Access Control Logic seperately" it is okay to have this approach.'}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Note :"})}),"\n",(0,i.jsxs)(n.p,{children:['The purpose of nested resolvers is not "magic", but rather to help organize code and maintain a clean architecture. They are necessary for delegating the computation of expensive or custom fields that only exist at the GraphQL level and not in the database. For instance, ',(0,i.jsx)(n.code,{children:"email"})," is an excellent example of such a field. Other examples include bank ",(0,i.jsx)(n.code,{children:"accountNumber"}),", ",(0,i.jsx)(n.code,{children:"bankBalance"}),", ",(0,i.jsx)(n.code,{children:"phoneNumber"})," (which have some kind of access control logic assiciated with them), and ",(0,i.jsx)(n.code,{children:"postCount"})," or ",(0,i.jsx)(n.code,{children:"joinedOrganizationsCount"})," which are not defined explicitly in the database. By using nested resolvers, we can delegate these operations to the appropriate location and ensure proper organization and maintenance of the code."]}),"\n",(0,i.jsx)(n.p,{children:"When resolving custom or complex fields within the parent resolver, it is possible to return errors related to those fields within the errors field of that parent resolver. While it is technically feasible to resolve an entire GraphQL schema and all related fields within a single resolver, doing so is not in accordance with GraphQL best practices. This approach differs from the root errors approach in that errors are type-safe, whereas in the root errors list they are not. However, when resolving errors for all fields or nested fields within the parent resolver, a long list of possible errors may result."}),"\n",(0,i.jsx)(n.p,{children:"Adopting a modular approach by extracting data and errors into resolvers can help isolate information to specific fields' resolvers, whether they are for scalar or complex objects. However, this may lead to the GraphQL schema not directly representing relations. As a result, many fields (scalar or complex) may have {success,errors} objects, which can appear peculiar."}),"\n",(0,i.jsx)(n.h2,{id:"errors-defined-in-schema-approach-vs-default-graphql-errors",children:"Errors Defined in Schema Approach vs Default GraphQL Errors"}),"\n",(0,i.jsx)(n.p,{children:"When it comes to error handling in GraphQL, there are two main approaches: errors defined in the schema and default GraphQL errors. Each approach has its own tradeoffs. Let's compare them in the table below:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{}),(0,i.jsx)(n.th,{children:"Errors Defined in Schema Approach"}),(0,i.jsx)(n.th,{children:"Default GraphQL Errors"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Definition"}),(0,i.jsx)(n.td,{children:"Errors are explicitly defined in the GraphQL schema"}),(0,i.jsx)(n.td,{children:"GraphQL provides standard error responses"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Control"}),(0,i.jsx)(n.td,{children:"Fine-grained control over error structure and behavior"}),(0,i.jsx)(n.td,{children:"Limited control, standardized error format"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Customization"}),(0,i.jsx)(n.td,{children:"Custom error types and specific error messages"}),(0,i.jsx)(n.td,{children:"Limited ability to customize error types and messages"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Integration"}),(0,i.jsx)(n.td,{children:"Integrated with the GraphQL schema and types"}),(0,i.jsx)(n.td,{children:"Separate from the schema, less tightly coupled"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Consistency"}),(0,i.jsx)(n.td,{children:"Ensures consistency in error handling across the API"}),(0,i.jsx)(n.td,{children:"Consistent error structure provided by the GraphQL spec"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Ease of Use"}),(0,i.jsx)(n.td,{children:"Requires explicit error handling in resolvers and clients"}),(0,i.jsx)(n.td,{children:"Automatically handles and returns errors in responses"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Flexibility"}),(0,i.jsx)(n.td,{children:"Can handle complex business logic and specific error cases"}),(0,i.jsx)(n.td,{children:"More suitable for simple error scenarios"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Error Extensions"}),(0,i.jsx)(n.td,{children:"Supports additional metadata or context for errors"}),(0,i.jsx)(n.td,{children:"Limited ability to extend error information"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Overhead"}),(0,i.jsx)(n.td,{children:"Requires additional code and complexity in the implementation"}),(0,i.jsx)(n.td,{children:"Less implementation overhead, simpler setup"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"Both approaches have their tradeoffs, and the choice depends on the specific requirements and complexity of your GraphQL API. The errors defined in the schema approach offers more control, customization, and flexibility but comes with additional implementation complexity. On the other hand, default GraphQL errors provide simplicity, consistency, and ease of use out of the box but may be limited in customization for complex error scenarios."}),"\n",(0,i.jsx)(n.p,{children:"Consider your project's needs and development constraints when choosing the error handling approach in GraphQL."})]})}function c(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},511151:(e,n,r)=>{r.d(n,{Z:()=>a,a:()=>t});var i=r(667294);const s={},o=i.createContext(s);function t(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);